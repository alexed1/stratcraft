({
    /** Returns the collection of local and global objects that are available for provided mode
     * @param {string} mode allowed values are: soql, if, gate
     */
    getAvailableObjects: function (mode) {
        var result = [];
        var addLocalObjects = false;
        var addGlobalObjects = false;
        switch (mode) {
            case 'filter':
                addLocalObjects = true;
                addGlobalObjects = true;
                break;
            case 'if':
                addGlobalObjects = true;
                break;
            case 'soql':
                addLocalObjects = true;
                break;
        }
        if (addGlobalObjects) {
            result.push({
                name: '',
                label: '--None--'
            });
            result.push({
                name: '$OnBehalfOf',
                label: '$OnBehalfOf',
                mappedOnTypes: 'User'
            });
            result.push({
                name: '$Record',
                label: '$Record',
            });
            result.push({
                name: '$Request',
                label: '$Request',
                mappedOnTypes: 'Request'
            });
            result.push({
                name: '$User',
                label: '$User',
                mappedOnTypes: 'User'
            });
        }
        if (addLocalObjects) {
            //Here we assume that we operate only on Proposition objects, so nothing else can funciton as a current item
            //Otherwise, this will be a good place to add traversal logic to check what object types are generated by the children of the current node
            result.push({
                name: '$Item',
                label: '$Item',
                mappedOnTypes: 'Proposition'
            });
        }
    },
    /** Converts different representaiton of operator to a unified form
     * @param {string} operator comparision operator (=, <, > etc.)
     */
    unifyOperators: function (operator) {
        if (!operator) {
            return null;
        }
        operator = operator.replace('&', '').replace(';', '').trim().toLowerCase();
        switch (operator) {
            case 'eq':
            case '==':
            case '=':
                return '=';

            case 'nq':
            case '!=':
                return '!=';

            case 'lt':
            case '<':
                return '<';

            case 'gt':
            case '>':
                return '>';
            case 'lte':
            case '=<':
                return '=<';
            case 'gte':
            case '>=':
                return '>=';
            case 'like':
                return 'like';
            default:
                return null;
        }
    },
    /** Parses specified expression into criteria tokens using specified mode and schema
     * @param {string} expression expression to parse
     * @param {string} mode allowed values are: soql, if, gate
     * @param {object} schema object that contains info about all types and their respective fields
     */
    x_parseExpression: function (expression, mode, schema) {
        if (mode === 'soql') {
            return this.x_parseSoqlExpression(expression, schema);
        }
        return this.x_parseCommonExpression(expresion, schema);
    },

    x_parseCommonExpression: function (expression, schema) {
        if (!expression) {
            return null;
        }
        var tokens = expression.split(' OR ');
        var self = this;
        var parsedSubExpressions = tokens.map(function (item) { return self.x_parseSubExpression(item, schema); })
        if (parsedSubExpressions.some(function (item) { return !item; })) {
            //If some subexpressions failed to be parsed, then the whole expression is also considered failed
            return null;
        }
        return parsedSubExpressions;
    },

    x_parseSoqlExpression: function (expression, schema) {
        if (!expression) {
            return null;
        }
        var tokens = expression.split('WHERE');
        if (tokens.length === 1) {
            //It means that there is no filter condition, thus our effective expression is true for all
            return [];
        }
        //Otherwise first token represents (or we assume so) SELECT clause and we just discard it
        //To protect ourselves from the case where WHERE word may appear inside string value we join the remaining tokens
        var whereStatement = tokens.join('WHERE').trim();
        if (!whereStatement) {
            //It means that there is WHERE keyword but there is nothing aftet it which is illegal
            return null;
        }
    },

    x_parseSubExpression: function (subexpression, schema) {
        if (!subexpression) {
            return null;
        }
        //Example: subexpression: $Record.Vendor__r.CreatedBy.FullName = 'John Doe'
        //Example: Tokens will contain ['$Record.Vendor__r,CreatedBy.FullName', '=', '\'John', 'Doe\'']
        var tokens = subexpression.split(' ');
        if (tokens.length < 3) {
            return null;
        }
        //The subexpression may contain sequences of spaces, leading and trailing spaces so we need to eliminate them
        //If this is the case, tokens will contain empty values which are legal only in the 'value' part of the expression
        //So now we look for the first non empty token and it will be a property path
        var propertyPathIndex = tokens.findIndex(function (item) { return item; });
        if (propertyPathIndex === -1) {
            return null;
        }
        //Now we look for the first (after property path) non empty token and it will be an operator
        var operatorIndex = tokens.findIndex(function (item, index) {
            return index > propertyPathIndex && item;
        });
        if (operatorIndex === -1) {
            return null;
        }
        //Now we look for the first (after operator) non empty token and it will be the first part of the value
        var valueStartIndex = tokens.findIndex(function (item, index) {
            return index > operatorIndex && item;
        });
        if (valueStartIndex === -1) {
            return null;
        }
        //Example: Property path is '$Record..Vendor__r.CreatedBy.FullName'
        var propertyPath = tokens[propertyPathIndex];
        //Example: Operator is '='
        var operator = this.unifyOperators(tokens[operatorIndex]);
        if (!operator) {
            return null;
        }
        //If there are more than one, we should join them (separated with space)
        //Example: Value tokens are ['\'John', 'Doe\'']
        var value = tokens.slice(valueStartIndex).join(' ');
        //Now we parses the propety path splitting it by dot
        tokens = propertyPath.split('.');
        if (tokens.some(function (item) { return item; })) {
            //If we encounter empty item it means that property path contain sequence of dots or leading/traling dots (which is illegal in property path)
            return null;
        }
        //Example: tokens will contain ['$Record','Vendor__r','CreatedBy','FullName']
        //If the first token starts with '$' it means that we are working with one of the global objects (e.g. $Record, $User)
        //Otherwise we assume implicit iteration variable (used in soql and filter). At the momenet we support only Proposition objects
        var object = '$Item';
        var objectType = 'Proposition';
        if (tokens[0].startsWith('$')) {
            object = tokens[0];
            //TODO: implement hint lookup
            objectType = 'Unknown',
                tokens.splice(0, 1);
        }
        //Example: tokens will contain ['Vendor__r','CreatedBy','FullName']
        if (tokens.length === 0) {
            //It means that we don't access any field of the global object which is illegal - you can't apply operators to the whole object
            return null;
        }
        var expectedParentType = objectType;
        var properties = [];
        tokens.forEach(function (currentFieldName) {
            var parentType = schema.typeMap[expectedParentType];
            //It means that we don't know, what is the type of the current field. In this case we create a fake one
            if (!parentType) {
                parentType = {
                    name: expectedParentType,
                    label: expectedParentType,
                    fieldList: [],
                    fieldMap: {}
                };
            }
            var currentField = parentType.fieldMap[currentFieldName];
            if (!currentField) {
                currentField = {
                    name: currentFieldName,
                    label: currentFieldName,
                    referenceTypeName: 'Unknown'
                };
            }
            properties.push({
                name: currentField.name,
                label: currentField.label,
                referenceTypeName: currentField.referenceTypeName
            });
            expectedParentType = currentField.referenceTypeName;
        });

        return {
            object: object,
            objectType: objectType,
            operator: operator,
            value: value,
            properties: properties
        };
    },

    x_stringifyExpression: function (expression, mode) {
        if (!expression) {
            return '';
        }
        if (mode === 'soql') {
            return this.x_stringifySoqlExpression(expression);
        }
        return this.x_stringifyCommonExpression(expression);
    },

    x_stringifyCommonExpression: function (expression) {
        if (expression.length > 0) {
            var self = this;
            var subExpressions = expression.map(function (item) { return self.x_stringifySubExpression(item); })
                .filter(function (item) { return !item; });
            return subExpressions.join(' OR ');
        }
        return '';
    },

    x_stringifySoqlExpression: function (expression) {
        var result = 'SELECT Name, Description, ActionReference FROM Proposition';
        var filter = this.x_stringifyCommonExpression(expression);
        if (filter) {
            return result.concat(' WHERE ', filter);
        }
        return result;
    },

    x_stringifySubExpression: function (subexpression) {
        if (!item.object || !item.operator || !item.value || item.properties || item.properties.length === 0) {
            return null;
        }
        var result = item.object === '$Item' ? '' : item.object;
        result = result.concat(
            '.',
            properties.join('.'),
            ' ',
            item.operator,
            ' ',
            properties[properties.length - 1].type === 'STRING' ? '\'' + item.value + '\'' : item.value);
        return result;
    },

    resolveExpression: function (cmp) {
        var isBuilderMode = cmp.get('v.isBuilderMode');
        var stringExpression = cmp.get('v.expression');
        var expression = cmp.get('v.criteria');
        var mode = cmp.get('v.mode');
        if (isBuilderMode) {
            return helper.x_stringifyExpression(stringExpression, mode);
        }
        return stringExpression;
    },

    initializeBuilder: function (cmp) {
        var stringExpression = cmp.get('v.expression');
        var schema = cmp.get('v._schema');
        var mode = cmp.get('v.mode');
        var expression = [];
        if (stringExpression) {
            expression = this.x_parseExpression(stringExpression, mode, schema);
        }
        if (!expression) {
            cmp.set('v.isBuilderMode', false);
            cmp.set('v.isLoading', false);
            return;
        }
        var isSoqlMode = mode === 'soql';
        if (expression.length == 0) {
            expression.push({
                object: isSoqlMode ? '$Item' : '',
                objectType: isSoqlMode ? 'Proposition' : '',
                operator: '=',
                value: '',
                properties: [
                    {
                        name: '',
                        label: '--None--',
                        referenceTypeName: ''
                    }
                ]
            });
        }
        cmp.set('v.criteria', expression);
        cmp.set('v.isLoading', false);
    }
})
