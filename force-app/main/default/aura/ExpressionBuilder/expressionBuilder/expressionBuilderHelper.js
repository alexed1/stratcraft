(
    {
        /** Returns the type that will be treated as root type (all subexpression will start from this type).
         * If specified mode supports access to the global objects (like $Record or $User) we introduce a fake type called '$global'.
         * This type will have all the global variables as its properties, thus we'll work with all levels of properties in the same manner
         * @param {Array} typeList the list of all types available to the current user
         * @param {string} mode allowed values are: soql, if, gate
         */
        _getRootType: function (typeList, mode) {
            var addLocalObjects = false;
            var addGlobalObjects = false;
            switch (mode) {
                case 'filter':
                    addLocalObjects = true;
                    //addGlobalObjects = true;
                    break;
                case 'if':
                    addGlobalObjects = true;
                    break;
                case 'soql':
                    addLocalObjects = true;
                    break;
            }
            var resultType = null;
            if (addGlobalObjects) {
                resultType = {
                    name: '$global',
                    label: '$global',
                    fieldList: []
                };
                // resultType.fieldList.push({
                //     name: '$OnBehalfOf',
                //     label: '$OnBehalfOf',
                //     type: 'User',
                //     isReference: true
                // });
                resultType.fieldList.push({
                    name: '$Record',
                    label: 'The record passed in when the strategy runs',
                    isReference: true
                });
                // resultType.fieldList.push({
                //     name: '$Request',
                //     label: '$Request',
                //     isReference: true
                // });
                resultType.fieldList.push({
                    name: '$User',
                    label: 'The user currently logged in the organization',
                    type: 'User',
                    isReference: true
                });
                typeList.push(resultType);
            }
            if (addLocalObjects) {
                //Here we assume that we operate only on Proposition objects, so nothing else can funciton as a current item
                //Otherwise, this will be a good place to add traversal logic to check what object types are generated by the children of the current node
                //TODO: probably worth checking if Proposition type exists (but it seems it is a standard one so it should exist)
                if (resultType) {
                    // resultType.fieldList.push({
                    //     name: '$Item',
                    //     label: '$Item',
                    //     type: 'Proposition',
                    //     isReference: true
                    // });
                } else {
                    resultType = typeList.find(function (type) { return type.name === 'Proposition'; });
                }
            }
            return resultType;
        },

        focusSubExpression: function (cmp, index) {
            window.setTimeout($A.getCallback(function () {
                var subExpressions = cmp.find('subExpression');
                if (!subExpressions) {
                    return;
                }
                var subExpression = Array.isArray(subExpressions)
                    ? subExpressions.find(function (subExpressionCmp) { return subExpressionCmp.get('v.subExpressionIndex') == index; })
                    : subExpressions;
                if (!subExpression) {
                    return;
                }
                subExpression.focus();
            }), 100);
        },

        _parseCommonExpression: function (expression, schema) {
            return _expressionParser.parseExpression(expression, schema);
        },

        _parseSoqlExpression: function (expression, schema) {
            if (!expression) {
                return []
            }
            var tokens = expression.split('WHERE');
            if (tokens.length === 1) {
                //It means that there is no filter condition, thus our effective expression is true for all
                return [];
            }
            //Otherwise first token represents (or we assume so) SELECT clause and we just discard it
            //To protect ourselves from the case where WHERE word may appear inside string value we join the remaining tokens
            var whereStatement = tokens.slice(1).join('WHERE').trim();
            return _expressionParser.parseExpression(whereStatement, schema);
        },
        /** Parses specified expression into sub expressions using specified mode and schema
         * @param {string} expression expression to parse
         * @param {string} mode allowed values are: soql, if, gate
         * @param {object} schema object that contains info about all types and their respective fields
         */
        parseExpression: function (expression, mode, schema) {
            var result = [];
            if (mode === 'soql') {
                result = this._parseSoqlExpression(expression, schema);
            } else {
                result = this._parseCommonExpression(expression, schema);
            }
            if (result && result.length === 0) {
                result.push(_expressionParser.createNewSubExpression(schema));
            }
            return result;
        },

        _stringifyExpression: function (expression, mode) {
            if (!expression) {
                return '';
            }
            if (mode === 'soql') {
                return this._stringifySoqlExpression(expression);
            }
            return this._stringifyCommonExpression(expression);
        },

        _stringifyCommonExpression: function (expression) {
            if (expression.length > 0) {
                var self = this;
                var subExpressions = expression.map(function (item) { return item.toString(); })
                    .filter(function (item) { return item; });
                return subExpressions.join(' OR ');
            }
            return '';
        },

        _stringifySoqlExpression: function (expression) {
            var result = 'SELECT Name, Description, ActionReference FROM Proposition';
            var filter = this._stringifyCommonExpression(expression);
            if (filter) {
                return result.concat(' WHERE ', filter);
            }
            return result;
        },

        validate: function (cmp) {
            var isBuilderMode = cmp.get('v.isBuilderMode');
            if (!isBuilderMode) {
                return true;
            }
            var subExpressonsCmp = cmp.find('subExpression');
            if (!Array.isArray(subExpressonsCmp)) {
                subExpressonsCmp = [subExpressonsCmp];
            }
            //First lets try to use whatever is entered in the textboxes as the expression value
            var result = subExpressonsCmp.reduce(function (result, subExpressionCmp) {
                return result & subExpressionCmp.tryFinalize();
            }, true);
            return result;
        },

        resolveExpression: function (cmp) {
            if (!this.validate(cmp)) {
                return '';
            }
            var isBuilderMode = cmp.get('v.isBuilderMode');
            var stringExpression = cmp.get('v.expression');
            var mode = cmp.get('v.mode');
            if (isBuilderMode) {
                var expression = cmp.get('v.subExpressions');
                return this._stringifyExpression(expression, mode);
            }
            return stringExpression;
        },

        initializeBuilder: function (cmp) {
            var expression = cmp.get('v.expression');
            var schema = cmp.get('v._schema');
            var mode = cmp.get('v.mode');
            var subExpressions = this.parseExpression(expression, mode, schema);
            if (!subExpressions) {
                cmp.set('v.isBuilderMode', false);
                cmp.set('v.isLoading', false);
                return;
            }
            cmp.set('v.subExpressions', subExpressions);
            cmp.set('v.isLoading', false);
        },
        /** Builds a schema object that contains the type that is used by the all subexpression as a root one, a collection of all types and a map of this types by their names
         * @param {Array} typeList the list of all the types available to the current user
         * @param {string} mode allowed vlaues are: soql, if, gate
         */
        buildSchema: function (typeList, mode) {
            var rootType = this._getRootType(typeList, mode);
            var schema = {
                rootType: rootType,
                typeList: typeList,
                typeNameMap: typeList.reduce(function (result, item) {
                    result[item.name] = item;
                    return result;
                }, {})
            };
            schema.typeList.forEach(function (type) {
                type.fieldNameMap = type.fieldList.reduce(function (result, field) {
                    result[field.name.toLowerCase()] = field;
                    return result;
                }, {});
                type.lookupFields = type.fieldList.map(function (field) { return { type: type, field: field } });
            });
            //This field will contain collection of pairs (field, owningType) for all fields of all types
            schema.lookupFields = schema.typeList.reduce(function (result, type) {
                return result.concat(type.lookupFields);
            }, []);
            return schema;
        }
    })
