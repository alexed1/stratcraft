(
    {
        /** Returns the type that will be treated as root type (all subexpression will start from this type).
         * If specified mode supports access to the global objects (like $Record or $User) we introduce a fake type called '@global'.
         * This type will have all the global variables as its properties, thus we'll work with all levels of properties in the same manner
         * @param {Array} typeList the list of all types available to the current user
         * @param {string} mode allowed values are: soql, if, gate
         */
        _getRootType: function (typeList, mode) {
            var addLocalObjects = false;
            var addGlobalObjects = false;
            switch (mode) {
                case 'filter':
                    addLocalObjects = true;
                    addGlobalObjects = true;
                    break;
                case 'if':
                    addGlobalObjects = true;
                    break;
                case 'soql':
                    addLocalObjects = true;
                    break;
            }
            var resultType = null;
            if (addGlobalObjects) {
                resultType = {
                    name: '@global',
                    label: '@global',
                    fieldList: []
                };
                resultType.fieldList.push({
                    name: '$OnBehalfOf',
                    label: '$OnBehalfOf',
                    type: 'User',
                    isReference: true
                });
                resultType.fieldList.push({
                    name: '$Record',
                    label: '$Record',
                    isReference: true
                });
                resultType.fieldList.push({
                    name: '$Request',
                    label: '$Request',
                    isReference: true
                });
                resultType.fieldList.push({
                    name: '$User',
                    label: '$User',
                    type: 'User',
                    isReference: true
                });
                typeList.push(resultType);
            }
            if (addLocalObjects) {
                //Here we assume that we operate only on Proposition objects, so nothing else can funciton as a current item
                //Otherwise, this will be a good place to add traversal logic to check what object types are generated by the children of the current node
                //TODO: probably worth checking if Proposition type exists (but it seems it is a standard one so it should exist)
                if (resultType) {
                    resultType.fieldList.push({
                        name: '$Item',
                        label: '$Item',
                        type: 'Proposition',
                        isReference: true
                    });
                } else {
                    resultType = typeList.find(function (type) { return type.name === 'Proposition'; });
                }
            }
            return resultType;
        },
        /** Converts different representaiton of operator to a unified form
         * @param {string} operator comparision operator (=, <, > etc.)
         */
        _unifyOperators: function (operator) {
            if (!operator) {
                return null;
            }
            operator = operator.replace('&', '').replace(';', '').trim().toLowerCase();
            switch (operator) {
                case 'eq':
                case '==':
                case '=':
                    return '=';

                case 'nq':
                case '!=':
                    return '!=';

                case 'lt':
                case '<':
                    return '<';

                case 'gt':
                case '>':
                    return '>';
                case 'lte':
                case '=<':
                    return '=<';
                case 'gte':
                case '>=':
                    return '>=';
                case 'like':
                    return 'like';
                default:
                    return null;
            }
        },

        _parseCommonExpression: function (expression, schema) {
            if (!expression) {
                return null;
            }
            var tokens = expression.split(' OR ');
            var self = this;
            var parsedSubExpressions = tokens.map(function (item) { return self._parseSubExpression(item, schema); })
            if (parsedSubExpressions.some(function (item) { return !item; })) {
                //If some subexpressions failed to be parsed, then the whole expression is also considered failed
                return null;
            }
            return parsedSubExpressions;
        },

        _parseSoqlExpression: function (expression, schema) {
            if (!expression) {
                return null;
            }
            var tokens = expression.split('WHERE');
            if (tokens.length === 1) {
                //It means that there is no filter condition, thus our effective expression is true for all
                return [];
            }
            //Otherwise first token represents (or we assume so) SELECT clause and we just discard it
            //To protect ourselves from the case where WHERE word may appear inside string value we join the remaining tokens
            var whereStatement = tokens.join('WHERE').trim();
            if (!whereStatement) {
                //It means that there is WHERE keyword but there is nothing aftet it which is illegal
                return null;
            }
        },

        _parseSubExpression: function (subexpression, schema) {
            if (!subexpression) {
                return null;
            }
            //Example: subexpression: $Record.Vendor__r.CreatedBy.FullName = 'John Doe'
            //Example: Tokens will contain ['$Record.Vendor__r,CreatedBy.FullName', '=', '\'John', 'Doe\'']
            var tokens = subexpression.split(' ');
            if (tokens.length < 3) {
                return null;
            }
            //The subexpression may contain sequences of spaces, leading and trailing spaces so we need to eliminate them
            //If this is the case, tokens will contain empty values which are legal only in the 'value' part of the expression
            //So now we look for the first non empty token and it will be a property path
            var propertyPathIndex = tokens.findIndex(function (item) { return item; });
            if (propertyPathIndex === -1) {
                return null;
            }
            //Now we look for the first (after property path) non empty token and it will be an operator
            var operatorIndex = tokens.findIndex(function (item, index) {
                return index > propertyPathIndex && item;
            });
            if (operatorIndex === -1) {
                return null;
            }
            //Now we look for the first (after operator) non empty token and it will be the first part of the value
            var valueStartIndex = tokens.findIndex(function (item, index) {
                return index > operatorIndex && item;
            });
            if (valueStartIndex === -1) {
                return null;
            }
            //Example: Property path is '$Record..Vendor__r.CreatedBy.FullName'
            var propertyPath = tokens[propertyPathIndex];
            //Example: Operator is '='
            var operator = this._unifyOperators(tokens[operatorIndex]);
            if (!operator) {
                return null;
            }
            //If there are more than one, we should join them (separated with space)
            //Example: Value tokens are ['\'John', 'Doe\'']
            var value = tokens.slice(valueStartIndex).join(' ');
            //Now we parses the propety path splitting it by dot
            tokens = propertyPath.split('.');
            if (tokens.some(function (item) { return !item; })) {
                //If we encounter empty item it means that property path contain sequence of dots or leading/traling dots (which is illegal in property path)
                return null;
            }
            //Example: tokens will contain ['$Record','Vendor__r','CreatedBy','FullName']
            //Now we build our collection of properties by iteratively checking the type of previous property
            var parentType = schema.rootType.name;
            var properties = [];
            tokens.forEach(function (propertyName) {
                var property = {
                    name: propertyName,
                    parentType: parentType
                };
                //The parent type was not specified - it means that we can't say for sure which object does the current property belong to
                if (!parentType) {
                    property.label = propertyName;
                    property.type = '';
                    property.lookupFields = schema.lookupFields;
                } else {
                    var knownType = schema.typeNameMap[parentType];
                    var knownProperty = knownType.fieldNameMap[propertyName];
                    if (knownProperty) {
                        property.label = knownProperty.label;
                        property.type = knownProperty.type;
                        property.lookupFields = knownProperty.type ? knownProperty.type.lookupFields || schema.lookupFields : schema.lookupFields;
                    }
                    property.label = knownProperty ? knownProperty.label : propertyName;
                    property.type = knownProperty ? knownProperty.type : '';
                    property.lookupFields = knownProperty && knownProperty.type ? knownProperty.type.lookupFields || schema.lookupFields : schema.lookupFields;
                }
                parentType = property.type;
                properties.push(property);
            });
            return {
                properties: properties,
                operator: operator,
                value: value
            };
            return properties;
        },

        _stringifyExpression: function (expression, mode) {
            if (!expression) {
                return '';
            }
            if (mode === 'soql') {
                return this._stringifySoqlExpression(expression);
            }
            return this._stringifyCommonExpression(expression);
        },

        _stringifyCommonExpression: function (expression) {
            if (expression.length > 0) {
                var self = this;
                var subExpressions = expression.map(function (item) { return self._stringifySubExpression(item); })
                    .filter(function (item) { return !item; });
                return subExpressions.join(' OR ');
            }
            return '';
        },

        _stringifySoqlExpression: function (expression) {
            var result = 'SELECT Name, Description, ActionReference FROM Proposition';
            var filter = this._stringifyCommonExpression(expression);
            if (filter) {
                return result.concat(' WHERE ', filter);
            }
            return result;
        },

        _stringifySubExpression: function (subexpression) {
            if (!item.object || !item.operator || !item.value || item.properties || item.properties.length === 0) {
                return null;
            }
            var result = item.object === '$Item' ? '' : item.object;
            result = result.concat(
                '.',
                properties.join('.'),
                ' ',
                item.operator,
                ' ',
                properties[properties.length - 1].type === 'STRING' ? '\'' + item.value + '\'' : item.value);
            return result;
        },

        resolveExpression: function (cmp) {
            var isBuilderMode = cmp.get('v.isBuilderMode');
            var stringExpression = cmp.get('v.expression');
            var expression = cmp.get('v.subExpressions');
            var mode = cmp.get('v.mode');
            if (isBuilderMode) {
                return this._stringifyExpression(stringExpression, mode);
            }
            return stringExpression;
        },

        initializeBuilder: function (cmp) {
            var expression = cmp.get('v.expression');
            var schema = cmp.get('v._schema');
            var mode = cmp.get('v.mode');
            var subExpressions = [];
            if (expression) {
                subExpressions = this.parseExpression(expression, mode, schema);
            }
            if (!subExpressions) {
                cmp.set('v.isBuilderMode', false);
                cmp.set('v.isLoading', false);
                return;
            }
            var isSoqlMode = mode === 'soql';
            if (subExpressions.length == 0) {
                subExpressions.push({
                    properties: [],
                    operator: '',
                    value: ''
                });
            }
            cmp.set('v.subExpressions', subExpressions);
            cmp.set('v.isLoading', false);
        },
        /** Builds a schema object that contains the type that is used by the all subexpression as a root one, a collection of all types and a map of this types by their names
         * @param {Array} typeList the list of all the types available to the current user
         * @param {string} mode allowed vlaues are: soql, if, gate
         */
        buildSchema: function (typeList, mode) {
            var rootType = this._getRootType(typeList, mode);
            var schema = {
                rootType: rootType,
                typeList: typeList,
                typeNameMap: typeList.reduce(function (result, item) {
                    result[item.name] = item;
                    return result;
                }, {})
            };
            schema.typeList.forEach(function (type) {
                type.fieldNameMap = type.fieldList.reduce(function (result, field) {
                    result[field.name] = field;
                    return result;
                }, {});
                type.fieldLabelMap = type.fieldList.reduce(function (result, field) {
                    result[field.label] = field;
                    return result;
                }, {})
                type.lookupFields = type.fieldList.map(function (field) { return { type: type, field: field } });
            });
            //This field will contain collection of pairs (field, owningType) for all fields of all types
            schema.lookupFields = schema.typeList.reduce(function (result, type) {
                return result.concat(type.lookupFields);
            }, []);
            return schema;
        },
        /** Parses specified expression into sub expressions using specified mode and schema
         * @param {string} expression expression to parse
         * @param {string} mode allowed values are: soql, if, gate
         * @param {object} schema object that contains info about all types and their respective fields
         */
        parseExpression: function (expression, mode, schema) {
            if (mode === 'soql') {
                return this._parseSoqlExpression(expression, schema);
            }
            return this._parseCommonExpression(expression, schema);
        },
    })
